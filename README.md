# OOD-Practice2
# به نام خدا

## تمرین شماره ۲ درس طراحی شی‌گرا

### "بخش ۱ - تشخیص زیرمسائل و الگوها"

#### -زیرمسئله ۱ – مدیریت وضعیت‌های تیکت و رفتار وابسته به وضعیت

**1. شرح مختصر**  
رفتار سیستم (پیام‌ها، اقدامات، و تغییر وضعیت بعدی) به‌طور کامل به وضعیت فعلی تیکت وابسته است و این منطق داخل یک متد طولانی با چندین شرط if-else متوالی نوشته شده است. این ساختار باعث می‌شود اضافه کردن وضعیت جدید یا تغییر رفتار یک وضعیت، نیازمند تغییر گسترده در کد مرکزی باشد.

**2. الگوی پیشنهادی: State Pattern**  
**دلیل:** وقتی رفتار یک شیء به شدت به حالت (state) داخلی آن وابسته است و تعداد حالت‌ها قابل توجه است یا ممکن است در آینده افزایش یابد، الگوی State بهترین انتخاب است زیرا هر حالت را به یک کلاس مجزا منتقل می‌کند و اصل OCP را به شدت تقویت می‌کند.

**3. روش اعمال الگو**  
- یک اینترفیس به نام `TicketState` تعریف می‌شود که متد `handle(Ticket ticket)` را دارد.  
- برای هر وضعیت یک کلاس مجزا ایجاد می‌شود که این اینترفیس را پیاده‌سازی کند (`NewState`, `AssignedState`, `InProgressState`, `ResolvedState`, `ClosedState`).  
- کلاس `Ticket` دیگر از `String` برای status استفاده نمی‌کند؛ به‌جای آن یک فیلد از نوع `TicketState currentState` دارد.  
- متد `handle()` در کلاس `Ticket` فقط صدا زدن `currentState.handle(this)` است.  
- هر کلاس وضعیت، داخل متد `handle` خودش:  
  • کارهای خاص آن وضعیت را انجام می‌دهد (چاپ پیام، تولید پاسخ، ارجاع و …)  
  • در انتها وضعیت بعدی را با `ticket.setState(new بعدی())` تنظیم می‌کند.

#### -زیرمسئله ۲ – تعیین واحد مسئول رسیدگی (ارجاع / Assignment)

**1. شرح مختصر**  
تصمیم‌گیری اینکه تیکت به کدام تیم/واحد ارجاع شود (مهندسی، پشتیبانی و …) بر اساس نوع تیکت (`type`) انجام می‌شود و این منطق به‌صورت شرطی داخل کد پخش شده است.

**2. الگوی پیشنهادی: Strategy Pattern**  
**دلیل:** این یک رفتار متغیر است که الگوریتم/روش آن بسته به نوع تیکت تغییر می‌کند و احتمال دارد در آینده انواع بیشتری اضافه شود. Strategy این امکان را می‌دهد که هر روش ارجاع یک کلاس جدا باشد و بدون تغییر کد اصلی بتوان استراتژی جدید اضافه کرد.

**3. روش اعمال الگو**  
- اینترفیس `AssignmentStrategy` با متد `String assign()` یا `void assign(Ticket ticket)` تعریف می‌شود.  
- کلاس‌های `BugAssignmentStrategy`, `SupportAssignmentStrategy` و … این اینترفیس را پیاده‌سازی می‌کنند.  
- در کلاس `AssignedState` (یا در خود `Ticket`) یک فیلد از نوع `AssignmentStrategy` وجود دارد.  
- در زمان handle شدن وضعیت Assigned، متد `assign()` از استراتژی فعلی فراخوانی می‌شود و پیام مناسب تولید/چاپ می‌گردد.  
- استراتژی می‌تواند در زمان ساخت تیکت (بر اساس type) انتخاب شود یا داخل `AssignedState` بر اساس type فعلی تیکت ساخته شود.

#### -زیرمسئله ۳ – تولید و ارسال پاسخ به کاربر

**1. شرح مختصر**  
متن یا نوع پاسخی که برای کاربر تولید و ارسال می‌شود بسته به نوع تیکت متفاوت است (پاسخ فنی برای باگ، پاسخ عمومی برای سایر موارد) و این منطق هم به‌صورت شرطی نوشته شده است.

**2. الگوی پیشنهادی: Strategy Pattern**  
**دلیل:** مشابه مورد قبلی؛ تولید پاسخ یک الگوریتم/رفتار متغیر است که می‌تواند استراتژی‌های مختلفی داشته باشد و در آینده استراتژی‌های جدید (پاسخ خودکار برای نوع خاصی از تیکت، پاسخ چندزبانه و …) به‌راحتی اضافه شود.

**3. روش اعمال الگو**  
- اینترفیس `ResponseStrategy` با متدی مانند `String generateResponse(Ticket ticket)` یا `String generateResponse(String request)` تعریف می‌شود.  
- کلاس‌های `BugResponseStrategy`, `GenericResponseStrategy` و در آینده انواع دیگر این اینترفیس را پیاده‌سازی می‌کنند.  
- در وضعیت `InProgressState` یک نمونه از `ResponseStrategy` نگهداری می‌شود.  
- هنگام handle شدن این وضعیت، متد `generateResponse` فراخوانی می‌شود، پاسخ تولید شده داخل تیکت ذخیره می‌شود و پیام ارسال پاسخ چاپ می‌گردد.

#### -زیرمسئله ۴ – ثبت رویداد / لاگ کردن عملیات (Logging)

**1. شرح مختصر**  
در انتهای هر پردازش یک پیام لاگ ساده چاپ می‌شود. این کار فعلاً ساده است اما اگر بخواهیم لاگ را به فایل، دیتابیس، سیستم مانیتورینگ یا چندین مقصد بفرستیم، کد فعلی باید به‌شدت تغییر کند.

**2. الگوی پیشنهادی (فعلاً)**  
Single Responsibility + جداسازی ساده  
**الگوی پیشنهادی آینده (در صورت پیچیده شدن):** Observer یا Strategy برای چند مقصد لاگ  
**دلیل:** فعلاً نیازی به پیچیدگی زیاد نیست، اما جداسازی لاگ از منطق اصلی باعث می‌شود بعداً بتوان بدون تغییر هسته سیستم، مکانیزم لاگ را ارتقا داد.

**3. روش اعمال الگو**  
- یک کلاس جداگانه `TicketLogger` (یا `TicketEventLogger`) ایجاد می‌شود.  
- متدهایی مانند `logHandling(Ticket ticket, String status)` یا `logTransition(Ticket ticket, String fromStatus, String toStatus)` تعریف می‌شود.  
- در انتهای متد `handle()` در `TicketService` یا داخل هر وضعیت (بعد از تغییر وضعیت)، این لاگر فراخوانی می‌شود.  
- در پیاده‌سازی فعلی فقط چاپ در کنسول انجام می‌دهد، اما ساختار به‌گونه‌ای است که بعداً بتوان چند لاگر (`ConsoleLogger`, `FileLogger`, `SlackLogger` و …) را اضافه کرد بدون تغییر جاهای دیگر.

### "بخش 2 -ترسیم Class diagram"
دیاگرام کلاس‌ها و روابط بین سیستم در تصویر زیر نمایش داده شده است.

https://github.com/M-mahdiL/OOD-Practice2/blob/main/ClassDiagram%20.png

### "بخش 3-  اعمال الگو"
 کد ها اصلاح و اضافه شده‌اند. البته مشکلاتی حل نشده باقی‌مانده‌اند که در سطح جزئیات هستند و نه در سطح کلان.
*در این مرحله از هوش مصنوعی grok استفاده شد.

### "بخش 4- تحلیل شی گرا"

#### 1. اصل SRP (Single Responsibility Principle)

در طراحی قبلی، کلاس TicketService چندین مسئولیت مختلف شامل مدیریت چرخه حیات، تصمیم‌گیری برای تخصیص، تولید پاسخ و لاگ‌گیری را بر عهده داشت. در طراحی جدید، این مسئولیت‌ها تفکیک شده‌اند: کلاس‌های وضعیت (TicketState) مسئول رفتار هر مرحله، استراتژی‌های تخصیص (AssignmentStrategy) مسئول نحوه ارجاع، و استراتژی‌های پاسخ (ResponseStrategy) مسئول تولید پاسخ هستند. این تغییر باعث شده هر کلاس تنها یک دلیل برای تغییر داشته باشد و کد خواناتر و قابل نگهداری‌تر شود.

---

#### 2. اصل OCP (Open/Closed Principle)

در کد قدیم، برای افزودن یک وضعیت جدید باید متد handle در TicketService را ویرایش کرده و یک بلوک if جدید به آن اضافه می‌کردیم. در طراحی جدید، با تعریف اینترفیس TicketState و پیاده‌سازی آن توسط کلاس‌های مختلف، می‌توان بدون تغییر در کلاس‌های موجود، صرفاً با افزودن یک کلاس وضعیت جدید (مثلاً OnHoldState) سیستم را توسعه داد. این یعنی کلاس‌ها برای توسعه باز و برای تغییر بسته شده‌اند.

---

#### 3. اصل LSP (Liskov Substitution Principle)

در طراحی قبلی ساختار وراثتی وجود نداشت که این اصل را بررسی کنیم. در طراحی جدید، تمام کلاس‌های وضعیت (NewState، AssignedState، InProgressState، ResolvedState، ClosedState) اینترفیس TicketState را به درستی پیاده‌سازی کرده‌اند. این بدان معناست که می‌توان هر یک از این کلاس‌ها را جایگزین دیگری کرد (با استفاده از متد setState) بدون اینکه برنامه دچار مشکل یا رفتار غیرمنتظره شود.

---

#### 4. اصل ISP (Interface Segregation Principle)

در کد قدیم اینترفیسی وجود نداشت. در طراحی جدید، اینترفیس‌ها به صورت تخصصی و کوچک طراحی شده‌اند: TicketState فقط متد handle دارد، AssignmentStrategy فقط متد assign، و ResponseStrategy فقط متد generateResponse. این یعنی کلاس‌هایی که این اینترفیس‌ها را پیاده‌سازی می‌کنند، مجبور به پیاده‌سازی متدهای اضافی و غیرمرتبط نیستند و وابستگی آنها تنها به چیزی است که واقعاً به آن نیاز دارند.

---

#### 5. اصل DIP (Dependency Inversion Principle)

در کد قدیم، TicketService مستقیماً به مقادیر konkret مانند ticket.type و ticket.channel وابسته بود و بر اساس آنها تصمیم‌گیری می‌کرد. در طراحی جدید، کلاس‌ها به اینترفیس‌ها وابسته هستند: Ticket به TicketState وابسته است، InProgressState به ResponseStrategy وابسته است، و AssignedState به AssignmentStrategy وابسته است. این وابستگی به انتزاع‌ها باعث انعطاف‌پذیری بیشتر و کاهش وابستگی به پیاده‌سازی‌های konkret شده است.

---

#### 6. اصل CRP (Composite Reuse Principle)

در کد قدیم، نه از ترکیب استفاده شده بود و نه از وراثت؛ همه چیز به صورت procedural با if-else پیاده‌سازی شده بود. در طراحی جدید، به جای وراثت از ترکیب استفاده شده است: Ticket یک شیء از نوع TicketState را در خود دارد، InProgressState یک ResponseStrategy را در خود دارد، و AssignedState یک AssignmentStrategy را در خود دارد. این امکان تغییر رفتار در زمان اجرا را فراهم کرده و انعطاف‌پذیری سیستم را افزایش داده است.

---

#### 7. اصل PLK
در کد قدیم، TicketService مستقیماً به فیلدهای داخلی Ticket مانند ticket.status، ticket.type و ticket.channel دسترسی داشت که قانون کمترین آشنایی را نقض می‌کرد. در طراحی جدید (با فرض پیاده‌سازی صحیح)، TicketService فقط با خود Ticket از طریق متد ticket.handle() ارتباط برقرار می‌کند و دیگر به جزئیات داخلی آن دسترسی ندارد. این باعث کاهش وابستگی‌ها و افزایش maintainability شده است، هرچند که دریافت همزمان پارامترهای Ticket و TicketService در متد handle وضعیت‌ها می‌تواند منجر به نقض خفیف این اصل شود.
