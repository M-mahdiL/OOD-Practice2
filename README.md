# OOD-Practice2
به نام خدا

تمرین شماره ۲ درس طراحی شی‌گرا

بخش ۱ (تشخیص زیرمسائل و الگوها)

زیرمسئله ۱ – مدیریت وضعیت‌های تیکت و رفتار وابسته به وضعیت

1. شرح مختصر:  
   رفتار سیستم (پیام‌ها، اقدامات، و تغییر وضعیت بعدی) به‌طور کامل به وضعیت فعلی تیکت وابسته است و این منطق داخل یک متد طولانی با چندین شرط if-else متوالی نوشته شده است. این ساختار باعث می‌شود اضافه کردن وضعیت جدید یا تغییر رفتار یک وضعیت، نیازمند تغییر گسترده در کد مرکزی باشد.

2. الگوی پیشنهادی: **State Pattern**  
   دلیل: وقتی رفتار یک شیء به شدت به حالت (state) داخلی آن وابسته است و تعداد حالت‌ها قابل توجه است یا ممکن است در آینده افزایش یابد، الگوی State بهترین انتخاب است زیرا هر حالت را به یک کلاس مجزا منتقل می‌کند و اصل OCP را به شدت تقویت می‌کند.

3. روش اعمال الگو:  
   - یک اینترفیس به نام `TicketState` تعریف می‌شود که متد `handle(Ticket ticket)` را دارد.  
   - برای هر وضعیت یک کلاس مجزا ایجاد می‌شود که این اینترفیس را پیاده‌سازی کند (`NewState`, `AssignedState`, `InProgressState`, `ResolvedState`, `ClosedState`).  
   - کلاس `Ticket` دیگر از `String` برای status استفاده نمی‌کند؛ به‌جای آن یک فیلد از نوع `TicketState currentState` دارد.  
   - متد `handle()` در کلاس `Ticket` فقط صدا زدن `currentState.handle(this)` است.  
   - هر کلاس وضعیت، داخل متد `handle` خودش:  
     • کارهای خاص آن وضعیت را انجام می‌دهد (چاپ پیام، تولید پاسخ، ارجاع و …)  
     • در انتها وضعیت بعدی را با `ticket.setState(new بعدی())` تنظیم می‌کند.


زیرمسئله ۲ – تعیین واحد مسئول رسیدگی (ارجاع / Assignment)

1. شرح مختصر:  
   تصمیم‌گیری اینکه تیکت به کدام تیم/واحد ارجاع شود (مهندسی، پشتیبانی و …) بر اساس نوع تیکت (`type`) انجام می‌شود و این منطق به‌صورت شرطی داخل کد پخش شده است.

2. الگوی پیشنهادی: **Strategy Pattern**  
   دلیل: این یک رفتار متغیر است که الگوریتم/روش آن بسته به نوع تیکت تغییر می‌کند و احتمال دارد در آینده انواع بیشتری اضافه شود. Strategy این امکان را می‌دهد که هر روش ارجاع یک کلاس جدا باشد و بدون تغییر کد اصلی بتوان استراتژی جدید اضافه کرد.

3. روش اعمال الگو:  
   - اینترفیس `AssignmentStrategy` با متد `String assign()` یا `void assign(Ticket ticket)` تعریف می‌شود.  
   - کلاس‌های `BugAssignmentStrategy`, `SupportAssignmentStrategy` و … این اینترفیس را پیاده‌سازی می‌کنند.  
   - در کلاس `AssignedState` (یا در خود `Ticket`) یک فیلد از نوع `AssignmentStrategy` وجود دارد.  
   - در زمان handle شدن وضعیت Assigned، متد `assign()` از استراتژی فعلی فراخوانی می‌شود و پیام مناسب تولید/چاپ می‌گردد.  
   - استراتژی می‌تواند در زمان ساخت تیکت (بر اساس type) انتخاب شود یا داخل `AssignedState` بر اساس type فعلی تیکت ساخته شود.


زیرمسئله ۳ – تولید و ارسال پاسخ به کاربر

1. شرح مختصر:  
   متن یا نوع پاسخی که برای کاربر تولید و ارسال می‌شود بسته به نوع تیکت متفاوت است (پاسخ فنی برای باگ، پاسخ عمومی برای سایر موارد) و این منطق هم به‌صورت شرطی نوشته شده است.

2. الگوی پیشنهادی: **Strategy Pattern**  
   دلیل: مشابه مورد قبلی؛ تولید پاسخ یک الگوریتم/رفتار متغیر است که می‌تواند استراتژی‌های مختلفی داشته باشد و در آینده استراتژی‌های جدید (پاسخ خودکار برای نوع خاصی از تیکت، پاسخ چندزبانه و …) به‌راحتی اضافه شود.

3. روش اعمال الگو:  
   - اینترفیس `ResponseStrategy` با متدی مانند `String generateResponse(Ticket ticket)` یا `String generateResponse(String request)` تعریف می‌شود.  
   - کلاس‌های `BugResponseStrategy`, `GenericResponseStrategy` و در آینده انواع دیگر این اینترفیس را پیاده‌سازی می‌کنند.  
   - در وضعیت `InProgressState` یک نمونه از `ResponseStrategy` نگهداری می‌شود.  
   - هنگام handle شدن این وضعیت، متد `generateResponse` فراخوانی می‌شود، پاسخ تولید شده داخل تیکت ذخیره می‌شود و پیام ارسال پاسخ چاپ می‌گردد.


زیرمسئله ۴ – ثبت رویداد / لاگ کردن عملیات (Logging)

1. شرح مختصر:  
   در انتهای هر پردازش یک پیام لاگ ساده چاپ می‌شود. این کار فعلاً ساده است اما اگر بخواهیم لاگ را به فایل، دیتابیس، سیستم مانیتورینگ یا چندین مقصد بفرستیم، کد فعلی باید به‌شدت تغییر کند.

2. الگوی پیشنهادی (فعلاً): Single Responsibility + جداسازی ساده  
   الگوی پیشنهادی آینده (در صورت پیچیده شدن): **Observer** یا **Strategy** برای چند مقصد لاگ  
   دلیل: فعلاً نیازی به پیچیدگی زیاد نیست، اما جداسازی لاگ از منطق اصلی باعث می‌شود بعداً بتوان بدون تغییر هسته سیستم، مکانیزم لاگ را ارتقا داد.

3. روش اعمال الگو:  
   - یک کلاس جداگانه `TicketLogger` (یا `TicketEventLogger`) ایجاد می‌شود.  
   - متدهایی مانند `logHandling(Ticket ticket, String status)` یا `logTransition(Ticket ticket, String fromStatus, String toStatus)` تعریف می‌شود.  
   - در انتهای متد `handle()` در `TicketService` یا داخل هر وضعیت (بعد از تغییر وضعیت)، این لاگر فراخوانی می‌شود.  
   - در پیاده‌سازی فعلی فقط چاپ در کنسول انجام می‌دهد، اما ساختار به‌گونه‌ای است که بعداً بتوان چند لاگر (`ConsoleLogger`, `FileLogger`, `SlackLogger` و …) را اضافه کرد بدون تغییر جاهای دیگر.
